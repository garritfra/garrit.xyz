{"pageProps":{"post":{"slug":"2021-04-07-pgp-guide","markdownBody":"\nIn the past week, I've been experimenting with PGP, or GPG in particular. In a nutshell, PGP is an encryption standard with a wide range of use cases. For quite some time, I didn't see the point of keeping a PGP keypair. It seemed like a burden to securely keep track of the key(s). Once you loose it, you will loose the trust of others. But after doing some research on the topic, I found that it's not actually that much of a hassle, while giving you many benefits.\n\n# The Why\n\nThe most obvious benefit is encrypting and decrypting messages and files. If you upload your public key, I can encrypt our private conversations. Nobody will be able to read what we're chatting about. If you fear that cloud providers will read through your documents, you can also go ahead and encrypt all of your data with your keypair.\n\nBut PGP is not just about encryption. A keypair also gives you a proof of identity. If I see that a piece of work is signed by you, I can be certain that you and only you have worked on this. By signing the keys of people we trust, we build a \"chain of trust\". A key with many signatures generally has a higher reputation than one without any signatures.\n\nTake Git commits for example. All it takes is a `git config user.email \"elon@spacex.com\"` and I can publish code under a different identity. But if everyone on the team signed their work, they will quickly see that a commit is missing its signature, because I'm simply not able to sign my work with Elon Musk's keypair. Only if they see a badge like this, they will know that they can trust it.\n\nYour keypair can also come in handy as a SSH key. Before I knew about PGP, I always had to install one key per machine I was working on. With PGP, you only have a single identity, and therefore you only have to install one key on your servers.\n\n# The How\n\nLet's first go over the process of setting up a keypair. For this, we will need the `gpg` command installed on our system. Usually, this is just a `<package manager> install gpg` away. Then, we will have to generate a keypair. The quickest way to get one is to use `gpg --gen-key`, but that will make some quirky assumptions about how you want to use your key.\n\nIn PGP, there is this concept of a **keyring**. A keyring has one master key and many subkeys. It is generally a good idea to have one fat master key that never expires and many small subkeys that last about a year or two. The benefit of structuring your keys like this is that you will always have your trusted keychain, and in case something goes south, E.g. your key gets compromised, you can replace that subkey and keep your identity.\n\nWith that in mind, let's create our master key. Run `gpg --full-gen-key` and follow the instructions. You probably want to use the `RSA and RSA (default)` option, and a key that is 4096 bits long (remember, this is the fat master key that never expires, so it must be secure). The comment can be left blank, unless you know what you are doing with that field. Enter a strong passphrase! If your private key were to get compromised, this passphrase is your last line of defense. Make it long, hard to crack but still rememberable. If everything went well, your key should be generated. Here's the full example output:\n\n```\nroot@c6acc9eb4fd1:/# gpg --full-gen-key\ngpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nPlease select what kind of key you want:\n   (1) RSA and RSA (default)\n   (2) DSA and Elgamal\n   (3) DSA (sign only)\n   (4) RSA (sign only)\n  (14) Existing key from card\nYour selection? 1\nRSA keys may be between 1024 and 4096 bits long.\nWhat keysize do you want? (3072) 4096\nRequested keysize is 4096 bits\nPlease specify how long the key should be valid.\n         0 = key does not expire\n      <n>  = key expires in n days\n      <n>w = key expires in n weeks\n      <n>m = key expires in n months\n      <n>y = key expires in n years\nKey is valid for? (0)\nKey does not expire at all\nIs this correct? (y/N) y\n\nGnuPG needs to construct a user ID to identify your key.\n\nReal name: Foo\nName must be at least 5 characters long\nReal name: Foo Bar\nEmail address: foo@bar.com\nComment:\nYou selected this USER-ID:\n    \"Foo Bar <foo@bar.com>\"\n\nChange (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O\nWe need to generate a lot of random bytes. It is a good idea to perform\nsome other action (type on the keyboard, move the mouse, utilize the\ndisks) during the prime generation; this gives the random number\ngenerator a better chance to gain enough entropy.\nWe need to generate a lot of random bytes. It is a good idea to perform\nsome other action (type on the keyboard, move the mouse, utilize the\ndisks) during the prime generation; this gives the random number\ngenerator a better chance to gain enough entropy.\ngpg: key C8E4854970B7A1A3 marked as ultimately trusted\ngpg: revocation certificate stored as '/root/.gnupg/openpgp-revocs.d/4E83F95221E92EDB933F155AC8E4854970B7A1A3.rev'\npublic and secret key created and signed.\n\npub   rsa4096 2021-04-07 [SC]\n      4E83F95221E92EDB933F155AC8E4854970B7A1A3\nuid                      Foo Bar <foo@bar.com>\nsub   rsa4096 2021-04-07 [E]\n```\n\nYou could stop here and use this key, but let's instead create some subkeys under that key, to make our lives a bit easier. Take the fingerprint of the key (that large number in the output) and run `gpg --edit-key --expert <your fingerprint>`. Run `addkey` three times to add these three keys:\n\n## Signing key\n\nThis key will be used to sign your work (git commits, tags, etc.).\n\n```\ngpg> addkey\n```\n\n1. Choose option \"RSA (set your own capabilities)\", which is currently number 8.\n1. Toggle E (Encryption) so the \"Current allowed actions\" only lists Sign and confirm with Q.\n1. Choose the keysize 2048 (or whatever you prefer).\n1. Choose the key expire date 1y (or whatever you prefer).\n1. Confirm twice, then enter your passphrase.\n\n## Encryption key\n\nThis key will be used to encrypt and decrypt messages.\n\n```\ngpg> addkey\n```\n\n1. Choose option \"RSA (set your own capabilities)\", which is currently number 8.\n1. Toggle S (Sign) so the \"Current allowed actions\" only lists Encryption and confirm with Q.\n1. Choose the keysize 2048 (or whatever you prefer).\n1. Choose the key expire date 1y (or whatever you prefer).\n1. Confirm twice, then enter your passphrase.\n\n## Authentication key\n\nThis key will be used for SSH authentication.\n\n```\ngpg> addkey\n```\n\n1. Choose option \"RSA (set your own capabilities)\", which is currently number 8.\n1. Toggle S (Signing), E (Encryption) and A (Authentication) so the \"Current allowed actions\" only lists Authenticate and confirm with Q.\n1. Choose the keysize 2048 (or whatever you prefer).\n1. Choose the key expire date 1y (or whatever you prefer).\n1. Confirm twice, then enter your passphrase.\n\nNow you should have one key per use case: signing, encrypting and authentication, each with an expiration date:\n\n```\nsec  rsa4096/C8E4854970B7A1A3\n     created: 2021-04-07  expires: never       usage: SC\n     trust: ultimate      validity: ultimate\nssb  rsa4096/C5F71423813B40A0\n     created: 2021-04-07  expires: never       usage: E\nssb  rsa2048/52D4D1D19533D8A5\n     created: 2021-04-07  expires: 2022-04-07  usage: S\nssb  rsa2048/072D841844E3F949\n     created: 2021-04-07  expires: 2022-04-07  usage: E\nssb  rsa2048/42E4F6E376DD92F6\n     created: 2021-04-07  expires: 2022-04-07  usage: A\n[ultimate] (1). Foo Bar <foo@bar.com>\n```\n\nSave your key, and optionally upload it to one of the many keyservers:\n\n```\ngpg> save\n\n$ gpg --keyserver keys.openpgp.org  --send-keys foo@bar.com\n```\n\n**Pro tip**: To set a default keyserver (I use `keys.opengpg.org`, but there are many others out there!), simply add it in your `~/.gnupg/gpg.conf` file:\n\n```\nkeyserver keys.openpgp.org\n```\n\nPeople can now import your public key via `gpg --keyserver keys.opengpg.org --search-keys foo@bar.com`.\n\nWe're done with the setup, let's put our keys to use!\n\n## Code Signing\n\nTo sign your code, you will have to tell git which key to use. Edit your global git options (`~/.gitconfig`) and add these fields:\n\n```\n[commit]\n\tgpgsign = true\n[tag]\n\tgpgsign = true\n[user]\n    name = Foo Bar\n\tsigningkey = 52D4D1D19533D8A5      # Use the ID of your signing key\n\temail = foo@bar.com\n```\n\nNow, whenever you add a commit, git will sign it with your key. You will have to let your git hosting provider know that this key is yours. Go to your account settings and look for a tab that says \"Manage (GPG) keys\". Where this tab is depends on your choice of service. Next, run `gpg --export --armor <your master key id>` and copy the resulting key into the input field of your git hosting service.\n\nWhenever you push a commit, its signature will be checked against that of your account. And that's all the magic!\n\n![A signed commit](/assets/signed_commit.png)\n\n## Encrypting messages\n\nIn order to send an encrypted message to someone, you will need his public key. There are numerous ways to obtain a public key of someone. The simplest way is to ask the person for the raw key. If it's in a text file, you can import it like so:\n\n```\ncat some_key.txt | gpg --import\n```\n\nOftentimes, people will store their keys on a keyserver, just like you have probably done it. To import someones key, simply search for it on a keyserver. I'll use my key here as an example.\n\n```\ngpg --keyserver keys.openpgp.org  --search-keys garrit@slashdev.space\n```\n\nNow, your computer should know about my key. To verify that it's actually me you have imported, you can check if the output of `gpg --fingerprint garrit@slashdev.space` matches my actual fingerprint: `2218 337E 54AA 1DBE 207B 404D BB54 AF7E B093 9F3D`.\n\nOptionally, if you trust that the key is actually associated to me, you can sign it. This let's other people know that you trust me, which helps build a so called \"chain of trust\". A key which has been signed by many people is generally more trustworthy than one that has no signatures.\n\n```\ngpg --sign-key garrit@slashdev.space\n```\n\nNow, let's encrypt a message that only I will be able to read:\n\n```\nprintf \"If you can read this, you've successfully decrypted this message\" | gpg --encrypt --sign --armor -r garrit@slashdev.space\n```\n\nFeel free to send this message to my email-address, I'm happy to chat with you!\n\nDecrypting something is as easy as encrypting something. Say the encrypted message lives in `message.txt.asc`. If you are the recipient, all you have to do is to run `gpg --decrypt message.txt.asc`.\n\n## SSH\n\nYour PGP key can also be used as an SSH key to authenticate on your servers.\n\nFirst we need to add the following to `~/.gnupg/gpg-agent.conf` to enable SSH support in gpg-agent.\n\n```\nenable-ssh-support\n```\n\nNext, we'll need to tell gpg which key to use. We need to get the so called `keygrip` of your authentication key and add it to the `~/.gnupg/sshcontrol`. The keygrip can be obtained by running `gpg -K --with-keygrip`. Just copy the keygrip of the authentication key and paste it into the `~/.gnupg/sshcontrol` file.\n\nThen, we want the ssh agent to know where to look for the key. Put this in your `.bashrc` file (or corresponding config):\n\n```\nexport GPG_TTY=$(tty)\nexport SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)\ngpgconf --launch gpg-agent\n```\n\nThen, run `ssh-add -l` to load the key directly.\n\nTo get the public ssh key of your keypair, run this command:\n\n```\ngpg --export-ssh-key foo@bar.com\n```\n\nand add the output to the `~/.ssh/authorized_keys` file on your server. When signing in, you should be prompted to enter the passphrase of your key and then authenticated.\n\n## Closing thoughts\n\nI hope by now you see the benefits you gain from having a PGP keypair. Whether you find it useful enough to set one up is of course up to you. It is however a good practice to at least sign your git commits as a proof of identity. There are services like [Keyoxide](https://keyoxide.org) that let you keep a \"public record\" of your key, so that other people can verify your identity more easily. If you set up your key, let me know by sending an encrypted message!\n\nThis is post 016 of [#100DaysToOffload](https://100daystooffload.com/).\n","frontmatter":{"title":"A pretty good guide to pretty good privacy","date":"2021-04-07","tags":"privacy, guide, 100DaysToOffload"},"tags":["privacy","guide","100DaysToOffload"]},"recommendedPosts":[{"slug":"2023-06-01-single-page-applications-on-github-pages","markdownBody":"\nMy latest project, [sendpasswords.net](https://sendpasswords.net/) is a [Single Page Application](https://developer.mozilla.org/en-US/docs/Glossary/SPA) deployed on GitHub Pages.\n\nGitHub Pages is configured in a way to host static HTML files without any bells and whistles. This means that if you try to fetch a document that's *not* the index, for example `/foo`, the server will try to load the file with that name. \n\nBy nature, SPAs only consist of a single HTML entry point (`index.html` in most cases). It's responsible for routing the user to the correct page if there are multiple paths. And here's the crux: if the user tries to load `/foo`, he will not land at the SPA entry point. Instead, he will see a `404` error.\n\n## The solution\n\nA `404` response will automatically return a file called `404.html`, which we can use to our advantage. After building the application, simply copy the `index.html` to `404.html`, as demonstrated by [this commit](https://github.com/garritfra/sendpasswords.net/commit/66bdb68c229a3ac3386f7816a746155e658eb586). This will use `index.html` to serve the application on the root level, and `404.html` to load *the same app* if the page doesn't exist as a file. Whether the `index.html` is needed if there's already a `404.html` is up to you. I left it in to make clear that this is just a workaround.\n\nThis is a [well known](https://stackoverflow.com/a/69308662/9046809) workaround, but I wanted to bring some extra awareness to it, since it's a problem I ran into a couple of times so far. Happy SPAing!\n\n---\n\nThis is post 069 (nice) of [#100DaysToOffload](https://100daystooffload.com/).\n","frontmatter":{"title":"Single Page Applications on GitHub Pages","date":"2023-06-01","tags":"100DaysToOffload, guide, note, web, javascript, github"},"tags":["100DaysToOffload","guide","note","web","javascript","github"]},{"slug":"2023-04-27-migrating-homeassistant-from-sd-to-ssd","markdownBody":"\nI finally got frustrated with the performance of my Raspberry Pi 4 running Homeassistant on a SD card, so I went ahead and got an SSD.\r\n\r\nThe migration was **very** easy:\r\n\r\n1. Create and download a full backup through the UI\r\n2. Flash Homeassistant onto the SSD\r\n3. Remove the SD card and plug the SSD into a USB 3.0 port of the Pi\r\n4. Boot\r\n5. Go through the onboarding procedure\r\n6. Restore Backup\r\n7. Profit\r\n\r\nIt worked like a charm! The speed has improved A LOT, and everything was set up as it should be. \r\n\r\n...Until we turned on the lights in the livingroom. My ZigBee-dongle, plugged into another USB port, wasn't able to communicate with the devices on the network.\r\n\r\nAfter some digging around, I came across several threads stating that an SSD over USB 3.0 apparently creates a lot of interference to surrounding hardware, including my ZigBee dongle. The fix was simple: either get an extension port for the dongle, or plug the SSD into a USB 2.0 port of the Pi. Since I didn't have an extension cord to get the dongle far away enough from the SSD, I went with the latter option for now. And that fixed it! The performance was much worse, but still better than the SD I used before. My next step will be to grab an extension cord from my parents. I'm sure they won't mind.\r\n\r\nI hope this helps!\r\n\r\n---\r\n\r\nThis is post 066 of [#100DaysToOffload](https://100daystooffload.com/).\r\n\r\n\r\n\r\n\r\n\n","frontmatter":{"title":"Migrating Homeassistant from SD to SSD","date":"2023-04-27","tags":"100DaysToOffload, guide, note, homeassistant, homelab"},"tags":["100DaysToOffload","guide","note","homeassistant","homelab"]},{"slug":"2023-04-12-instant-dark-theme","markdownBody":"\nThanks to [Jacksons](https://jacksonchen666.com/) [update to darktheme.club](https://github.com/garritfra/darktheme.club/pull/79), I just came across a neat little [CSS property](https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme) that turns a mostly CSS-free document into a pleasantly dark site:\r\n\r\n```css\r\n:root {\r\n  color-scheme: light dark;\r\n}\r\n```\r\n\r\nThis will adjust all elements on the page to the color scheme preferred by the user - without any other custom styles! ðŸ¤¯ It is also [widely supported](https://caniuse.com/mdn-css_properties_color-scheme) by browsers.\r\n\r\nI've always been quite dependent on CSS-frameworks for any project I'm starting. Going forward, I'd be interested to see how framework-less sites would feel using this property. If all else fails, there's always the awesome [simple.css](https://simplecss.org/) library, which you can slap on top of a raw document to make it pretty (and dark, if preferred) without using custom classes.\r\n\r\n---\r\n\r\nThis is post 064 of [#100DaysToOffload](https://100daystooffload.com/).\n","frontmatter":{"title":"Instant dark theme","date":"2023-04-12","tags":"100DaysToOffload, guide, note, learnings, web, css, til"},"tags":["100DaysToOffload","guide","note","learnings","web","css","til"]},{"slug":"2023-03-30-designing-resilient-cloud-infrastructure","markdownBody":"\r\nAs mentioned in a [previous post](/posts/2023-03-16-terraform-project-learnings), I'm currently finishing up building my first cloud infrastructure on AWS for a client at work. During the development, I learned a lot about designing components to be resilient and scalable. Here are some key takeaways.\r\n\r\nOne of the most critical components of a resilient infrastructure is redundancy. On AWS, you place your components inside a \"region\". This could be `eu-central-1` (Frankfurt) or `us-east-1` (North Virgina), etc. To further reduce the risk of an outage, each region is divided into multiple [Availability Zones](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html) (AZs). The AZs of a region are usually located some distance apart from each other. In case of a flood, a fire or a bomb detonating near one AZ, the other AZs should in most cases still be intact. You should have at least two, preferably three replicas of each component across multiple availability zones in a region. By having replicas of your components in different availability zones, you reduce the risk of downtime caused by an outage in a single availability zone.\r\n\r\nAnother way to ensure scalability and resilience for your database is to use [Aurora Serverless v2](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.html). This database service is specifically designed for scalable, on-demand, and cost-effective performance. The database scales itself up or down based on the workload, which allows you to automatically and dynamically adjust the database capacity to meet the demand of your application, ensuring that your application is responsive and performs well without the need for manual intervention. Adding Serverless instances to an existing RDS cluster is also a seemless proccess.\r\n\r\nIn addition to switching to Aurora Serverless v2, using read replicas for cache and database in a separate availability zone can act as a hot standby without extra configuration. Keep in mind that read replicas are only utilized by explicitly using the read-only endpoint of a cluster. But even if you're only using the \"main\" cluster endpoint (and therefore just the primary instance), a read replica can promote itself to the primary instance in case of a fail over, which drastically reduces downtime.\r\n\r\nWhen using Amazon Elastic Container Service (ECS), use Fargate as opposed to EC2 instances. Fargate is a serverless compute engine for containers that allows you to run containers without having to manage the underlying infrastructure. It smartly locates instances across availability zones, ensuring that your application is always available.\r\n\r\nIn conclusion, you should always ensure that there are more than one instance of a component in your infrastructure. There are also services on AWS that abstract away the physical infrastructure (Fargate, S3, Lambda) and use a multi-AZ pattern by default.\r\n\r\n---\r\n\r\nThis is post 061 of [#100DaysToOffload](https://100daystooffload.com/).\r\n\r\n","frontmatter":{"title":"Designing resilient cloud infrastructure","date":"2023-03-30","tags":"100DaysToOffload, infrastructure, aws, guide, note, learnings"},"tags":["100DaysToOffload","infrastructure","aws","guide","note","learnings"]},{"slug":"2023-03-23-fullscreen-terminals-in-vscode","markdownBody":"\nI often find myself using a \"real\" terminal alongside my VSCode setup, because for some tasks the built-in terminal, due to its small size, is quite flimsy to use. *But*! I just found out there's a a way to switch the terminal into fullscreen mode, using the \"View: Toggle Maximized Panel\" command.\r\n\r\nYou can bind it to a shortcut, which makes switching between editor and terminal a breeze! Simply add this to your `keybindings.json` (also accessible via the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette)):\r\n\r\n```\r\n    {\r\n        \"key\": \"cmd+alt+m\",\r\n        \"command\": \"workbench.action.toggleMaximizedPanel\"\r\n    }\r\n```\r\n\r\n### References\r\n\r\n- [Original StackOverflow answer](https://stackoverflow.com/a/48512128/9046809)\r\n\r\n---\r\n\r\nThis is post 059 of [#100DaysToOffload](https://100daystooffload.com/).\r\n\n","frontmatter":{"title":"Fullscreen Terminals in VSCode","date":"2023-03-23","tags":"100DaysToOffload, guide, note, editors"},"tags":["100DaysToOffload","guide","note","editors"]}]},"__N_SSG":true}