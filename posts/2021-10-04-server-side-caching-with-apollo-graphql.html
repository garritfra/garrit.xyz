<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta charSet="utf-8"/><title>Server-Side Caching with Apollo GraphQL | Garrit&#x27;s Notes</title><meta name="Description" content="Generalist software developer writing about scalable infrastructure, fullstack development and DevOps practices."/><link rel="icon" type="image/svg+xml" href="/favicon.svg"/><link rel="manifest" href="/site.webmanifest"/><link rel="webmention" href="https://webmention.io/garrit.xyz/webmention"/><link rel="pingback" href="https://webmention.io/garrit.xyz/xmlrpc"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/935debb317df188e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/935debb317df188e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-144ddb6b9c2105c7.js" defer=""></script><script src="/_next/static/chunks/main-2ec2bff4dc625bbc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5d4795abae9e13c0.js" defer=""></script><script src="/_next/static/chunks/630-15567ca4e241c039.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpost%5D-276741fc94169dfe.js" defer=""></script><script src="/_next/static/kjrg5oXtqjKulQ4r7fmrx/_buildManifest.js" defer=""></script><script src="/_next/static/kjrg5oXtqjKulQ4r7fmrx/_ssgManifest.js" defer=""></script></head><body><div id="__next"><section class="layout"><header class="header"><nav class="nav" role="navigation" aria-label="main navigation"><div class="header__container"><a href="/" class="header__container__logo">Garrit&#x27;s Notes</a></div><ul class="header__links"><li><a href="/posts">Blog</a></li><li><a href="/contact">Contact</a></li><li><a href="/links">More ...</a></li></ul></nav></header><div class="content"><article class="page h-entry"><div class="page__info"><h1 class="p-name">Server-Side Caching with Apollo GraphQL</h1><time class="page__info__date">Oct 04 2021</time><p class="tag-list"><a href="/posts?tags=javascript">#<!-- -->javascript</a><a href="/posts?tags=graphql">#<!-- -->graphql</a><a href="/posts?tags=guide">#<!-- -->guide</a><a href="/posts?tags=100DaysToOffload">#<!-- -->100DaysToOffload</a><a href="/posts?tags=programming">#<!-- -->programming</a><a href="/posts?tags=tech">#<!-- -->tech</a></p></div><div class="page__body e-content"><p>I recently implemented server-side caching for one of our applications at work.
This guide tries to document that I&#x27;ve learned. It assumes that you are using
an apollo server of version 3 or higher.</p>
<h3 id="what-is-server-side-caching?">What is Server-Side Caching?</h3>
<p>The point of server-side caching is to reduce the load of your database by
“remembering” the results of a query for a certain period. If the exact same
query comes in again, that remembered result will be returned.</p>
<p>Caching should be handled with care. You should never enable caching for your
entire application. Instead, you should identify the bottlenecks and develop a
strategy to overcome them.</p>
<h3 id="enabling-caching-on-the-server">Enabling caching on the server</h3>
<p>The Apollo Team has done a great job
<a href="https://www.apollographql.com/docs/apollo-server/performance/caching/">documenting</a>
the caching behavior of their server. To add caching to your existing
Apollo-Server, you first have to add the <code>responseCachePlugin</code> to your
configuration as shown
<a href="https://www.apollographql.com/docs/apollo-server/performance/caching/#caching-with-responsecacheplugin-advanced">here</a>:</p>
<pre><code class="language-js">import responseCachePlugin from &quot;apollo-server-plugin-response-cache&quot;;

const server = new ApolloServer({
	// ...other options...
	plugins: [responseCachePlugin()],
});
</code></pre>
<p>Then, you have to configure a cache backend. By default, Apollo Server will
store the caches in RAM, but I’d recommend <a href="https://www.apollographql.com/docs/apollo-server/data/data-sources/#using-memcachedredis-as-a-cache-storage-backend">using
Redis</a>
(or Memcached, if you like), especially if your application is spread across
multiple instances of the same backend.</p>
<pre><code class="language-js">const { BaseRedisCache } = require(&quot;apollo-server-cache-redis&quot;);
const Redis = require(&quot;ioredis&quot;);

const server = new ApolloServer({
	// ...
	cache: new BaseRedisCache({
		plugins: [responseCachePlugin()],
		client: new Redis({
			host: &quot;redis-server&quot;,
		}),
	}),
});
</code></pre>
<blockquote>
<p>Note that you have to use the ioredis library here. node_redis is deprecated
as of v2.6.0 of apollo-server-cache-redis.</p>
</blockquote>
<p>If everything went well, your server should now know how to cache responses!
This alone won’t get you very far, since it doesn’t know what to cache.</p>
<h3 id="telling-apollo-what-to-cache">Telling Apollo what to cache</h3>
<p>To make a type cachable, you have to declare <strong>cache hints</strong>. These properties
can either be set in the
<a href="https://www.apollographql.com/docs/apollo-server/performance/caching/#in-your-resolvers-dynamic">resolver</a>,
or
<a href="https://www.apollographql.com/docs/apollo-server/performance/caching/#in-your-schema-static">statically</a>
in the schema. To keep it simple, this guide will stick to the static method.
Feel free to experiment with the dynamic approach though!</p>
<p>To enable cache hints, simply add the following directive to your schema (you
only have to do this once):</p>
<pre><code class="language-gql">enum CacheControlScope {
	PUBLIC
	PRIVATE
}

directive @cacheControl(
	maxAge: Int
	scope: CacheControlScope
	inheritMaxAge: Boolean
) on FIELD_DEFINITION | OBJECT | INTERFACE | UNION
</code></pre>
<p>Now you can add the <code>@cacheControl</code> directive to every type that should be cached.</p>
<pre><code class="language-gql"># This type will be cached for 30 seconds
type Post @cacheControl(maxAge: 30) {
	id: ID!
	title: String
	author: Author
	comments: [Comment]
}
</code></pre>
<p>For security reasons, these conditions are <a href="https://www.apollographql.com/docs/apollo-server/performance/caching/#why-are-these-the-maxage-defaults">very
strict</a>:</p>
<blockquote>
<p>Our philosophy behind Apollo Server caching is that a response should only be
considered cacheable if every part of that response opts in to being
cacheable.</p>
</blockquote>
<p>This means that every type needs to explicitly decide how long it should be
cached. According to this note, the example above actually won’t be cached at
all!</p>
<p>Having to specify the <code>maxAge</code> of every type would be tedious, so the authors
have come up with the <code>inheritMaxAge</code> property, which allows the type to
inherit the settings from its parent. So, in order to make our example
cachable, we have to enable cache control for all its subfields, either by
setting the <code>maxAge</code> explicitly or by inheriting it from the parent:</p>
<pre><code class="language-gql">type Post @cacheControl(maxAge: 30) {
	id: ID!
	title: String
	author: Author
	comments: [Comment]
}

type Author @cacheControl(inheritMaxAge: true) {
	id: ID!
	name: String
}

type Comment @cacheControl(inheritMaxAge: true) {
	id: ID!
	body: String
}
</code></pre>
<p>Now, whenever you query a <code>Post</code>, it will be thrown in the cache. If you query
the type again within 30 seconds, the query resolver won’t execute. Instead, it
will be read from the cache. Keep in mind that cache hints can also be set on
<code>query</code> and <code>mutation</code> fields. This can be handy if you want to cache the
entire response of a request.</p>
<h3 id="gotcha-1:-multiple-response-variations">Gotcha 1: Multiple Response Variations</h3>
<p>The use-case where this topic first came up required us to have different
responses based on the type of the logged in user. An <code>Admin</code> should see a
different result than a <code>Visitor</code>. If you ignore this fact, it could be that a
visitor could see the cache result of a query previously executed by an admin!</p>
<p>This problem can be counteracted by setting extra information in the cache key
via <code>extraCacheKeyData</code> (see
<a href="https://www.apollographql.com/docs/apollo-server/performance/caching/#configuring-reads-and-writes">this</a>
paragraph):</p>
<pre><code class="language-js">plugins: [
    responseCachePlugin({
        extraCacheKeyData: (ctx) =&gt; (
            ctx.context.auth.isAdmin
        ),
    }),
],
</code></pre>
<p>This example can create two distinct caches: One for users that are marked as
admins, and one for regular users.</p>
<h3 id="gotcha-2:-user-specific-caches">Gotcha 2: User-specific caches</h3>
<p>Besides caching for a group of users, you can also cache responses <a href="https://www.apollographql.com/docs/apollo-server/performance/caching/#identifying-users-for-private-responses">for every
user
individually</a>.
You may have noticed that you can also set a <code>scope</code> field in the cache control
directive. This will only cache the response if a user is logged in:</p>
<pre><code class="language-gql">type Post {
	id: ID!
	title: String
	author: Author @cacheControl(maxAge: 10, scope: PRIVATE)
}
</code></pre>
<p>Apollo determines if a user is logged in or not, based on if the <code>sessionId</code>
function has returned a value other than <code>null</code>.</p>
<pre><code class="language-js">import responseCachePlugin from &quot;apollo-server-plugin-response-cache&quot;;
const server = new ApolloServer({
	// ...other settings...
	plugins: [
		responseCachePlugin({
			sessionId: (requestContext) =&gt;
				requestContext.request.http.headers.get(&quot;sessionid&quot;) || null,
		}),
	],
});
</code></pre>
<p>I’m unsure how effective this pattern is, since every user will receive its key
in the cache. This kind of defeats the purpose of server-side caching, which is
meant to reduce load on the database. If you’re trying to cache fields for
individual users, you might also want to take a look at client-side caching via
<a href="https://github.com/appmotion/apollo-augmented-hooks">apollo-augmented-hooks</a>.</p>
<p>This is post 020 of <a href="https://100daystooffload.com/">#100DaysToOffload</a>.</p><p class="horizontal-list"><button>💌️ Reply via E-Mail</button><button>🔗 Share</button><button>✏️ Fix Typo</button></p><hr/><h2>Continue Reading</h2><div><div class="blog__list__post"><time class="blog__list__post__date">Mar 25 2025</time><br/><a href="/posts/2025-03-25-container-interfaces">Container Interfaces</a></div><div class="blog__list__post"><time class="blog__list__post__date">Feb 27 2025</time><br/><a href="/posts/2025-02-27-a-trick-to-manage-frequently-used-prompts-in-claude-chatgpt">A trick to manage frequently used prompts in Claude/ChatGPT</a></div><div class="blog__list__post"><time class="blog__list__post__date">Sep 24 2024</time><br/><a href="/posts/2024-09-24-installing-mssql-client-drivers-for-a-php-application">Installing MSSQL Client Drivers for a PHP Application</a></div><div class="blog__list__post"><time class="blog__list__post__date">Aug 31 2024</time><br/><a href="/posts/2024-08-31-sentiment-analysis-using-ml-models">Sentiment analysis using ML models</a></div><div class="blog__list__post"><time class="blog__list__post__date">Aug 03 2024</time><br/><a href="/posts/2024-08-03-how-embedding-models-encode-semantic-meaning">How embedding models encode semantic meaning</a></div></div></div></article></div><footer class="footer"><div class="notice"><p>I invite you to read my new book<!-- --> <a target="_blank" href="https://www.buymeacoffee.com/garrit/e/233695">Five Years of Blogging: Ideas, Opinions and Guides written 2019 to 2024</a>. Becoming a member on<!-- --> <a target="_blank" href="https://www.buymeacoffee.com/garrit">Buy Me a Coffee</a> <!-- -->will grant you free access to the book!</p><a href="https://www.buymeacoffee.com/garrit/extras"><img src="/assets/five-years-of-blogging-cover-3d.png" alt="Cover of Five Years of Blogging" loading="lazy"/></a></div><div class="footer__content"><h3>Links of Interest</h3><a href="/rss.xml">RSS Feed</a><br/><a href="/todo">Todo List</a><br/><a href="https://keys.openpgp.org/vks/v1/by-fingerprint/2218337E54AA1DBE207B404DBB54AF7EB0939F3D">PGP Key</a><br/><a href="/guestbook">Guestbook</a><br/><a href="/blogroll">Blogroll</a><br/><a href="/ctf">Capture the Flag</a><h3>Elsewhere</h3><a href="https://github.com/garritfra" rel="me">Github</a><br/><a href="https://www.linkedin.com/in/garritfranke/">LinkedIn</a><br/><a href="https://fosstodon.org/@garritfra">Mastodon (ActivityPub)</a><br/><a href="/contact">Contact</a></div><a href="https://www.buymeacoffee.com/garrit" target="_blank"><img src="https://img.buymeacoffee.com/button-api/?text=Buy me a tea&amp;emoji=&amp;slug=garrit&amp;button_colour=FFB300&amp;font_colour=000000&amp;font_family=Cookie&amp;outline_colour=000000&amp;coffee_colour=ffffff"/></a><p>👻 Proud member of<!-- --> <a target="_blank" href="https://darktheme.club/">darktheme.club</a> <!-- -->👻</p><p>© 2018-<!-- -->2025<!-- --> Garrit Franke<br/><a href="/privacy">Privacy</a> |<!-- --> <a target="_blank" href="https://github.com/garritfra/garrit.xyz">Source Code</a></p></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"2021-10-04-server-side-caching-with-apollo-graphql","markdownBody":"\nI recently implemented server-side caching for one of our applications at work.\nThis guide tries to document that I've learned. It assumes that you are using\nan apollo server of version 3 or higher.\n\n### What is Server-Side Caching?\n\nThe point of server-side caching is to reduce the load of your database by\n“remembering” the results of a query for a certain period. If the exact same\nquery comes in again, that remembered result will be returned.\n\nCaching should be handled with care. You should never enable caching for your\nentire application. Instead, you should identify the bottlenecks and develop a\nstrategy to overcome them.\n\n### Enabling caching on the server\n\nThe Apollo Team has done a great job\n[documenting](https://www.apollographql.com/docs/apollo-server/performance/caching/)\nthe caching behavior of their server. To add caching to your existing\nApollo-Server, you first have to add the `responseCachePlugin` to your\nconfiguration as shown\n[here](https://www.apollographql.com/docs/apollo-server/performance/caching/#caching-with-responsecacheplugin-advanced):\n\n```js\nimport responseCachePlugin from \"apollo-server-plugin-response-cache\";\n\nconst server = new ApolloServer({\n\t// ...other options...\n\tplugins: [responseCachePlugin()],\n});\n```\n\nThen, you have to configure a cache backend. By default, Apollo Server will\nstore the caches in RAM, but I’d recommend [using\nRedis](https://www.apollographql.com/docs/apollo-server/data/data-sources/#using-memcachedredis-as-a-cache-storage-backend)\n(or Memcached, if you like), especially if your application is spread across\nmultiple instances of the same backend.\n\n```js\nconst { BaseRedisCache } = require(\"apollo-server-cache-redis\");\nconst Redis = require(\"ioredis\");\n\nconst server = new ApolloServer({\n\t// ...\n\tcache: new BaseRedisCache({\n\t\tplugins: [responseCachePlugin()],\n\t\tclient: new Redis({\n\t\t\thost: \"redis-server\",\n\t\t}),\n\t}),\n});\n```\n\n\u003e Note that you have to use the ioredis library here. node_redis is deprecated\n\u003e as of v2.6.0 of apollo-server-cache-redis.\n\nIf everything went well, your server should now know how to cache responses!\nThis alone won’t get you very far, since it doesn’t know what to cache.\n\n### Telling Apollo what to cache\n\nTo make a type cachable, you have to declare **cache hints**. These properties\ncan either be set in the\n[resolver](https://www.apollographql.com/docs/apollo-server/performance/caching/#in-your-resolvers-dynamic),\nor\n[statically](https://www.apollographql.com/docs/apollo-server/performance/caching/#in-your-schema-static)\nin the schema. To keep it simple, this guide will stick to the static method.\nFeel free to experiment with the dynamic approach though!\n\nTo enable cache hints, simply add the following directive to your schema (you\nonly have to do this once):\n\n```gql\nenum CacheControlScope {\n\tPUBLIC\n\tPRIVATE\n}\n\ndirective @cacheControl(\n\tmaxAge: Int\n\tscope: CacheControlScope\n\tinheritMaxAge: Boolean\n) on FIELD_DEFINITION | OBJECT | INTERFACE | UNION\n```\n\nNow you can add the `@cacheControl` directive to every type that should be cached.\n\n```gql\n# This type will be cached for 30 seconds\ntype Post @cacheControl(maxAge: 30) {\n\tid: ID!\n\ttitle: String\n\tauthor: Author\n\tcomments: [Comment]\n}\n```\n\nFor security reasons, these conditions are [very\nstrict](https://www.apollographql.com/docs/apollo-server/performance/caching/#why-are-these-the-maxage-defaults):\n\n\u003e Our philosophy behind Apollo Server caching is that a response should only be\n\u003e considered cacheable if every part of that response opts in to being\n\u003e cacheable.\n\nThis means that every type needs to explicitly decide how long it should be\ncached. According to this note, the example above actually won’t be cached at\nall!\n\nHaving to specify the `maxAge` of every type would be tedious, so the authors\nhave come up with the `inheritMaxAge` property, which allows the type to\ninherit the settings from its parent. So, in order to make our example\ncachable, we have to enable cache control for all its subfields, either by\nsetting the `maxAge` explicitly or by inheriting it from the parent:\n\n```gql\ntype Post @cacheControl(maxAge: 30) {\n\tid: ID!\n\ttitle: String\n\tauthor: Author\n\tcomments: [Comment]\n}\n\ntype Author @cacheControl(inheritMaxAge: true) {\n\tid: ID!\n\tname: String\n}\n\ntype Comment @cacheControl(inheritMaxAge: true) {\n\tid: ID!\n\tbody: String\n}\n```\n\nNow, whenever you query a `Post`, it will be thrown in the cache. If you query\nthe type again within 30 seconds, the query resolver won’t execute. Instead, it\nwill be read from the cache. Keep in mind that cache hints can also be set on\n`query` and `mutation` fields. This can be handy if you want to cache the\nentire response of a request.\n\n### Gotcha 1: Multiple Response Variations\n\nThe use-case where this topic first came up required us to have different\nresponses based on the type of the logged in user. An `Admin` should see a\ndifferent result than a `Visitor`. If you ignore this fact, it could be that a\nvisitor could see the cache result of a query previously executed by an admin!\n\nThis problem can be counteracted by setting extra information in the cache key\nvia `extraCacheKeyData` (see\n[this](https://www.apollographql.com/docs/apollo-server/performance/caching/#configuring-reads-and-writes)\nparagraph):\n\n```js\nplugins: [\n    responseCachePlugin({\n        extraCacheKeyData: (ctx) =\u003e (\n            ctx.context.auth.isAdmin\n        ),\n    }),\n],\n```\n\nThis example can create two distinct caches: One for users that are marked as\nadmins, and one for regular users.\n\n### Gotcha 2: User-specific caches\n\nBesides caching for a group of users, you can also cache responses [for every\nuser\nindividually](https://www.apollographql.com/docs/apollo-server/performance/caching/#identifying-users-for-private-responses).\nYou may have noticed that you can also set a `scope` field in the cache control\ndirective. This will only cache the response if a user is logged in:\n\n```gql\ntype Post {\n\tid: ID!\n\ttitle: String\n\tauthor: Author @cacheControl(maxAge: 10, scope: PRIVATE)\n}\n```\n\nApollo determines if a user is logged in or not, based on if the `sessionId`\nfunction has returned a value other than `null`.\n\n```js\nimport responseCachePlugin from \"apollo-server-plugin-response-cache\";\nconst server = new ApolloServer({\n\t// ...other settings...\n\tplugins: [\n\t\tresponseCachePlugin({\n\t\t\tsessionId: (requestContext) =\u003e\n\t\t\t\trequestContext.request.http.headers.get(\"sessionid\") || null,\n\t\t}),\n\t],\n});\n```\n\nI’m unsure how effective this pattern is, since every user will receive its key\nin the cache. This kind of defeats the purpose of server-side caching, which is\nmeant to reduce load on the database. If you’re trying to cache fields for\nindividual users, you might also want to take a look at client-side caching via\n[apollo-augmented-hooks](https://github.com/appmotion/apollo-augmented-hooks).\n\nThis is post 020 of [#100DaysToOffload](https://100daystooffload.com/).\n","frontmatter":{"title":"Server-Side Caching with Apollo GraphQL","date":"2021-10-04","tags":"javascript, graphql, guide, 100DaysToOffload, programming, tech"},"tags":["javascript","graphql","guide","100DaysToOffload","programming","tech"]},"recommendedPosts":[{"slug":"2025-03-25-container-interfaces","frontmatter":{"title":"Container Interfaces","date":"2025-03-25","tags":"infrastructure, note, tech"},"tags":["infrastructure","note","tech"]},{"slug":"2025-02-27-a-trick-to-manage-frequently-used-prompts-in-claude-chatgpt","frontmatter":{"title":"A trick to manage frequently used prompts in Claude/ChatGPT","date":"2025-02-27","tags":"guide, note, tech, llm, ai"},"tags":["guide","note","tech","llm","ai"]},{"slug":"2024-09-24-installing-mssql-client-drivers-for-a-php-application","frontmatter":{"title":"Installing MSSQL Client Drivers for a PHP Application","date":"2024-09-24","tags":"guide, note, web, tech, programming, php"},"tags":["guide","note","web","tech","programming","php"]},{"slug":"2024-08-31-sentiment-analysis-using-ml-models","frontmatter":{"title":"Sentiment analysis using ML models","date":"2024-08-31","tags":"note, tech, ai"},"tags":["note","tech","ai"]},{"slug":"2024-08-03-how-embedding-models-encode-semantic-meaning","frontmatter":{"title":"How embedding models encode semantic meaning","date":"2024-08-03","tags":"note, tech, math, llm, ai"},"tags":["note","tech","math","llm","ai"]}]},"__N_SSG":true},"page":"/posts/[post]","query":{"post":"2021-10-04-server-side-caching-with-apollo-graphql"},"buildId":"kjrg5oXtqjKulQ4r7fmrx","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>