<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta charSet="utf-8"/><title>About Container Interfaces | Garrit&#x27;s Notes</title><meta name="Description" content="Generalist software developer writing about scalable infrastructure, fullstack development and DevOps practices."/><link rel="icon" type="image/svg+xml" href="/favicon.svg"/><link rel="manifest" href="/site.webmanifest"/><link rel="webmention" href="https://webmention.io/garrit.xyz/webmention"/><link rel="pingback" href="https://webmention.io/garrit.xyz/xmlrpc"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/935debb317df188e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/935debb317df188e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-144ddb6b9c2105c7.js" defer=""></script><script src="/_next/static/chunks/main-2ec2bff4dc625bbc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5d4795abae9e13c0.js" defer=""></script><script src="/_next/static/chunks/630-15567ca4e241c039.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpost%5D-276741fc94169dfe.js" defer=""></script><script src="/_next/static/8sga-Z_G4HzP5nog1yO1z/_buildManifest.js" defer=""></script><script src="/_next/static/8sga-Z_G4HzP5nog1yO1z/_ssgManifest.js" defer=""></script></head><body><div id="__next"><section class="layout"><header class="header"><nav class="nav" role="navigation" aria-label="main navigation"><div class="header__container"><a href="/" class="header__container__logo">Garrit&#x27;s Notes</a></div><ul class="header__links"><li><a href="/posts">Blog</a></li><li><a href="/contact">Contact</a></li><li><a href="/links">More ...</a></li></ul></nav></header><div class="content"><article class="page h-entry"><div class="page__info"><h1 class="p-name">About Container Interfaces</h1><time class="page__info__date">Mar 25 2025</time><p class="tag-list"><a href="/posts?tags=infrastructure">#<!-- -->infrastructure</a><a href="/posts?tags=note">#<!-- -->note</a><a href="/posts?tags=tech">#<!-- -->tech</a></p></div><div class="page__body e-content"><p>There are a couple of interfaces that container orchestration systems (like <a href="https://kubernetes.io">Kubernetes</a>) implement to expose certain behavior to their container workloads. I will only be talking about Kubernetes in this post since it&#x27;s the orchestrator I&#x27;m most comfortable with, but some interfaces are also implemented in other orchestrators (like <a href="https://www.nomadproject.io/">HashiCorp Nomad</a>) too, which makes the interfaces cross-platform.</p>
<h2 id="container-storage-interface-(csi)">Container Storage Interface (CSI)</h2>
<p>Storage behavior used to be built into Kubernetes. The <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">container storage interface (CSI)</a> defines a unified interface to manage storage volumes, regardless of the orchestrator (as long as they implement the CSI). This makes it way easier for third-party storage providers to expose data to Kubernetes. If a storage provider implements this interface, orchestrators can use it to provision volumes to containers. Notable storage providers are:</p>
<ul>
<li><a href="https://github.com/kubernetes-csi/csi-driver-nfs">NFS</a></li>
<li><a href="https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/cinder">Cinder (Openstack)</a></li>
<li><a href="https://github.com/ceph/ceph-csi">Ceph</a></li>
<li><a href="https://github.com/kubernetes-sigs/aws-ebs-csi-driver">AWS EBS</a></li>
</ul>
<p>A full list of CSI drivers can be found <a href="https://kubernetes-csi.github.io/docs/drivers.html">here</a>.</p>
<h2 id="container-runtime-interface-(cri)">Container Runtime Interface (CRI)</h2>
<p>The <a href="https://github.com/kubernetes/cri-api">Container Runtime Interface (CRI)</a> is an API that allows Kubernetes to use different container runtimes without needing to recompile the entire Kubernetes codebase. Before CRI, Kubernetes had a direct integration with Docker, making it difficult to use alternative container runtimes.</p>
<p>CRI defines the API between Kubernetes components (specifically kubelet) and container runtimes. This abstraction allows Kubernetes to support multiple container runtimes simultaneously, giving users the flexibility to choose the runtime that best fits their needs. Some popular container runtimes that implement the CRI include:</p>
<ul>
<li><a href="https://containerd.io/">containerd</a> - The industry-standard container runtime that powers Docker and is maintained by the CNCF</li>
<li><a href="https://cri-o.io/">CRI-O</a> - A lightweight runtime specifically designed for Kubernetes</li>
<li><a href="https://katacontainers.io/">Kata Containers</a> - A secure container runtime that uses hardware virtualization for stronger isolation</li>
</ul>
<p>With CRI, switching between different runtimes becomes more straightforward, allowing operators to optimize for security, performance, or compatibility based on their specific requirements.</p>
<h2 id="container-network-interface-(cni)">Container Network Interface (CNI)</h2>
<p>The <a href="https://github.com/containernetworking/cni">Container Network Interface (CNI)</a> defines a standard for configuring network interfaces for Linux containers. Similar to CSI and CRI, the CNI was created to decouple Kubernetes from specific networking implementations, allowing for a pluggable architecture.</p>
<p>CNI plugins are responsible for allocating IP addresses to pods and ensuring proper network connectivity between pods, nodes, and external networks. They implement features like network policies, load balancing, and network security. Some popular CNI plugins include:</p>
<ul>
<li><a href="https://www.tigera.io/project-calico/">Calico</a> - Known for its performance, flexibility, and strong network policy support</li>
<li><a href="https://cilium.io/">Cilium</a> - Uses eBPF for high-performance networking and security</li>
<li><a href="https://github.com/flannel-io/flannel">Flannel</a> - Simple overlay network focused on ease of use</li>
<li><a href="https://github.com/aws/amazon-vpc-cni-k8s">AWS VPC CNI</a> - Integrates pods directly with Amazon VPC networking</li>
</ul>
<p>Each CNI plugin has its strengths and is suitable for different use cases. For example, Calico excels at enforcing network policies, Cilium is optimized for performance and observability, while Flannel is valued for its simplicity.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>One thing I&#x27;ve always admired about Kubernetes is its pluggable architecture. These standardized interfaces (CSI, CRI, and CNI) showcase how well-designed the system really is. Instead of building everything into the core, the Kubernetes team made the smart decision to create extension points that allow the community to innovate without touching the core codebase.</p>
<p>The great news? You don&#x27;t <em>have</em> to swap out all these components or even understand them deeply to use Kubernetes effectively. While the array of options might seem daunting at first glance, most Kubernetes distributions (like EKS, GKE, AKS, or Rancher) come with sane defaults that work well out of the box. They&#x27;ve already made sensible choices about which storage, runtime, and networking components to include.</p>
<p>This pluggability is what makes Kubernetes so powerful for those who need it. Need a specific storage solution? Plug in a CSI driver. Want a more secure container runtime? Swap in a different CRI implementation. But for everyone else, the defaults will serve you just fine.</p>
<p>The beauty of this approach is that it gives you room to grow. Start with the defaults, and when you have specific requirements, the extension points are there waiting for you. That&#x27;s the real magic of Kubernetes ‚Äì it works great out of the box but doesn&#x27;t limit your options as your needs evolve.</p><p class="horizontal-list"><button>üíåÔ∏è Reply via E-Mail</button><button>üîó Share</button><button>‚úèÔ∏è Fix Typo</button></p><hr/><h2>Continue Reading</h2><div><div class="blog__list__post"><time class="blog__list__post__date">Feb 27 2025</time><br/><a href="/posts/2025-02-27-a-trick-to-manage-frequently-used-prompts-in-claude-chatgpt">A trick to manage frequently used prompts in Claude/ChatGPT</a></div><div class="blog__list__post"><time class="blog__list__post__date">Sep 24 2024</time><br/><a href="/posts/2024-09-24-installing-mssql-client-drivers-for-a-php-application">Installing MSSQL Client Drivers for a PHP Application</a></div><div class="blog__list__post"><time class="blog__list__post__date">Aug 31 2024</time><br/><a href="/posts/2024-08-31-sentiment-analysis-using-ml-models">Sentiment analysis using ML models</a></div><div class="blog__list__post"><time class="blog__list__post__date">Aug 03 2024</time><br/><a href="/posts/2024-08-03-how-embedding-models-encode-semantic-meaning">How embedding models encode semantic meaning</a></div><div class="blog__list__post"><time class="blog__list__post__date">Jul 02 2024</time><br/><a href="/posts/2024-07-02-linkdump-llms">üîó Linkdump: LLMs</a></div></div></div></article></div><footer class="footer"><div class="notice"><p>I invite you to read my new book<!-- --> <a target="_blank" href="https://www.buymeacoffee.com/garrit/e/233695">Five Years of Blogging: Ideas, Opinions and Guides written 2019 to 2024</a>. Becoming a member on<!-- --> <a target="_blank" href="https://www.buymeacoffee.com/garrit">Buy Me a Coffee</a> <!-- -->will grant you free access to the book!</p><a href="https://www.buymeacoffee.com/garrit/extras"><img src="/assets/five-years-of-blogging-cover-3d.png" alt="Cover of Five Years of Blogging" loading="lazy"/></a></div><div class="footer__content"><h3>Links of Interest</h3><a href="/rss.xml">RSS Feed</a><br/><a href="/todo">Todo List</a><br/><a href="https://keys.openpgp.org/vks/v1/by-fingerprint/2218337E54AA1DBE207B404DBB54AF7EB0939F3D">PGP Key</a><br/><a href="/guestbook">Guestbook</a><br/><a href="/blogroll">Blogroll</a><br/><a href="/ctf">Capture the Flag</a><h3>Elsewhere</h3><a href="https://github.com/garritfra" rel="me">Github</a><br/><a href="https://www.linkedin.com/in/garritfranke/">LinkedIn</a><br/><a href="https://fosstodon.org/@garritfra">Mastodon (ActivityPub)</a><br/><a href="/contact">Contact</a></div><a href="https://www.buymeacoffee.com/garrit" target="_blank"><img src="https://img.buymeacoffee.com/button-api/?text=Buy me a tea&amp;emoji=&amp;slug=garrit&amp;button_colour=FFB300&amp;font_colour=000000&amp;font_family=Cookie&amp;outline_colour=000000&amp;coffee_colour=ffffff"/></a><p>üëª Proud member of<!-- --> <a target="_blank" href="https://darktheme.club/">darktheme.club</a> <!-- -->üëª</p><p>¬© 2018-<!-- -->2025<!-- --> Garrit Franke<br/><a href="/privacy">Privacy</a> |<!-- --> <a target="_blank" href="https://github.com/garritfra/garrit.xyz">Source Code</a></p></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"2025-03-25-container-interfaces","markdownBody":"\nThere are a couple of interfaces that container orchestration systems (like [Kubernetes](https://kubernetes.io)) implement to expose certain behavior to their container workloads. I will only be talking about Kubernetes in this post since it's the orchestrator I'm most comfortable with, but some interfaces are also implemented in other orchestrators (like [HashiCorp Nomad](https://www.nomadproject.io/)) too, which makes the interfaces cross-platform.\n\n## Container Storage Interface (CSI)\n\nStorage behavior used to be built into Kubernetes. The [container storage interface (CSI)](https://github.com/container-storage-interface/spec/blob/master/spec.md) defines a unified interface to manage storage volumes, regardless of the orchestrator (as long as they implement the CSI). This makes it way easier for third-party storage providers to expose data to Kubernetes. If a storage provider implements this interface, orchestrators can use it to provision volumes to containers. Notable storage providers are:\n\n* [NFS](https://github.com/kubernetes-csi/csi-driver-nfs)\n* [Cinder (Openstack)](https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/cinder)\n* [Ceph](https://github.com/ceph/ceph-csi)\n* [AWS EBS](https://github.com/kubernetes-sigs/aws-ebs-csi-driver)\n\nA full list of CSI drivers can be found [here](https://kubernetes-csi.github.io/docs/drivers.html).\n\n## Container Runtime Interface (CRI)\n\nThe [Container Runtime Interface (CRI)](https://github.com/kubernetes/cri-api) is an API that allows Kubernetes to use different container runtimes without needing to recompile the entire Kubernetes codebase. Before CRI, Kubernetes had a direct integration with Docker, making it difficult to use alternative container runtimes.\n\nCRI defines the API between Kubernetes components (specifically kubelet) and container runtimes. This abstraction allows Kubernetes to support multiple container runtimes simultaneously, giving users the flexibility to choose the runtime that best fits their needs. Some popular container runtimes that implement the CRI include:\n\n* [containerd](https://containerd.io/) - The industry-standard container runtime that powers Docker and is maintained by the CNCF\n* [CRI-O](https://cri-o.io/) - A lightweight runtime specifically designed for Kubernetes\n* [Kata Containers](https://katacontainers.io/) - A secure container runtime that uses hardware virtualization for stronger isolation\n\nWith CRI, switching between different runtimes becomes more straightforward, allowing operators to optimize for security, performance, or compatibility based on their specific requirements.\n\n## Container Network Interface (CNI)\n\nThe [Container Network Interface (CNI)](https://github.com/containernetworking/cni) defines a standard for configuring network interfaces for Linux containers. Similar to CSI and CRI, the CNI was created to decouple Kubernetes from specific networking implementations, allowing for a pluggable architecture.\n\nCNI plugins are responsible for allocating IP addresses to pods and ensuring proper network connectivity between pods, nodes, and external networks. They implement features like network policies, load balancing, and network security. Some popular CNI plugins include:\n\n* [Calico](https://www.tigera.io/project-calico/) - Known for its performance, flexibility, and strong network policy support\n* [Cilium](https://cilium.io/) - Uses eBPF for high-performance networking and security\n* [Flannel](https://github.com/flannel-io/flannel) - Simple overlay network focused on ease of use\n* [AWS VPC CNI](https://github.com/aws/amazon-vpc-cni-k8s) - Integrates pods directly with Amazon VPC networking\n\nEach CNI plugin has its strengths and is suitable for different use cases. For example, Calico excels at enforcing network policies, Cilium is optimized for performance and observability, while Flannel is valued for its simplicity.\n\n## Wrapping Up\n\nOne thing I've always admired about Kubernetes is its pluggable architecture. These standardized interfaces (CSI, CRI, and CNI) showcase how well-designed the system really is. Instead of building everything into the core, the Kubernetes team made the smart decision to create extension points that allow the community to innovate without touching the core codebase.\n\nThe great news? You don't *have* to swap out all these components or even understand them deeply to use Kubernetes effectively. While the array of options might seem daunting at first glance, most Kubernetes distributions (like EKS, GKE, AKS, or Rancher) come with sane defaults that work well out of the box. They've already made sensible choices about which storage, runtime, and networking components to include.\n\nThis pluggability is what makes Kubernetes so powerful for those who need it. Need a specific storage solution? Plug in a CSI driver. Want a more secure container runtime? Swap in a different CRI implementation. But for everyone else, the defaults will serve you just fine.\n\nThe beauty of this approach is that it gives you room to grow. Start with the defaults, and when you have specific requirements, the extension points are there waiting for you. That's the real magic of Kubernetes ‚Äì it works great out of the box but doesn't limit your options as your needs evolve.\n","frontmatter":{"title":"About Container Interfaces","date":"2025-03-25","tags":"infrastructure, note, tech"},"tags":["infrastructure","note","tech"]},"recommendedPosts":[{"slug":"2025-02-27-a-trick-to-manage-frequently-used-prompts-in-claude-chatgpt","frontmatter":{"title":"A trick to manage frequently used prompts in Claude/ChatGPT","date":"2025-02-27","tags":"guide, note, tech, llm, ai"},"tags":["guide","note","tech","llm","ai"]},{"slug":"2024-09-24-installing-mssql-client-drivers-for-a-php-application","frontmatter":{"title":"Installing MSSQL Client Drivers for a PHP Application","date":"2024-09-24","tags":"guide, note, web, tech, programming, php"},"tags":["guide","note","web","tech","programming","php"]},{"slug":"2024-08-31-sentiment-analysis-using-ml-models","frontmatter":{"title":"Sentiment analysis using ML models","date":"2024-08-31","tags":"note, tech, ai"},"tags":["note","tech","ai"]},{"slug":"2024-08-03-how-embedding-models-encode-semantic-meaning","frontmatter":{"title":"How embedding models encode semantic meaning","date":"2024-08-03","tags":"note, tech, math, llm, ai"},"tags":["note","tech","math","llm","ai"]},{"slug":"2024-07-02-linkdump-llms","frontmatter":{"title":"üîó Linkdump: LLMs","date":"2024-07-02","tags":"note, tech, linkdump, llm, ai"},"tags":["note","tech","linkdump","llm","ai"]}]},"__N_SSG":true},"page":"/posts/[post]","query":{"post":"2025-03-25-container-interfaces"},"buildId":"8sga-Z_G4HzP5nog1yO1z","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>